
lab2:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000007c  20000000  20000000  00008000  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.attributes 00000021  00000000  00000000  0000807c  2**0
                  CONTENTS, READONLY
  2 .debug_line   00000095  00000000  00000000  0000809d  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_info   000000b4  00000000  00000000  00008132  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_abbrev 00000028  00000000  00000000  000081e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000040  00000000  00000000  00008210  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

20000000 <_start>:
20000000:	20000800 	.word	0x20000800
20000004:	2000002b 	.word	0x2000002b

20000008 <initGPIO>:
@ Output:
	.global	initGPIO
	.type	initGPIO, %function
initGPIO:
	@ Load GPIO_OUT_BASE address
	movw	r1, #:lower16:GPIO_OUT_BASE
20000008:	f243 0100 	movw	r1, #12288	; 0x3000
	movt	r1, #:upper16:GPIO_OUT_BASE
2000000c:	f2c4 0101 	movt	r1, #16385	; 0x4001
	
	@ Calculate the GPIOx register address
				@ left shift by 2 => i*4
				@ GPIO_OUT_BASE + i*4
	lsl r0, #2
20000010:	ea4f 0080 	mov.w	r0, r0, lsl #2
	add r0, r0, r1
20000014:	4408      	add	r0, r1
				
	@ Write 1 to config register to set GPIO as output
	mov r2, #1
20000016:	f04f 0201 	mov.w	r2, #1
	str r2, [r0]
2000001a:	6002      	str	r2, [r0, #0]
	
	bx	lr @ Return
2000001c:	4770      	bx	lr

2000001e <setGPIO>:
@ Output:
	.global	setGPIO
	.type	setGPIO, %function
setGPIO:
	@ Load GPIO_OUT register address
	movw	r1, #:lower16:GPIO_OUT
2000001e:	f243 0188 	movw	r1, #12424	; 0x3088
	movt	r1, #:upper16:GPIO_OUT
20000022:	f2c4 0101 	movt	r1, #16385	; 0x4001
	
	@ Write 32bit value to GPIO output register
	str r0, [r1]
20000026:	6008      	str	r0, [r1, #0]
	
	bx	lr @ Return
20000028:	4770      	bx	lr

2000002a <main>:
	.thumb

	.type	main, %function
main:
	@ Load SYSREG_SOFT_RST_CR address
	movw	r0, #:lower16:SYSREG_SOFT_RST_CR
2000002a:	f242 0030 	movw	r0, #8240	; 0x2030
	movt	r0, #:upper16:SYSREG_SOFT_RST_CR
2000002e:	f2ce 0004 	movt	r0, #57348	; 0xe004
	@ Reset GPIO hardware
	ldr	r1, [r0, #0]
20000032:	6801      	ldr	r1, [r0, #0]
	orr	r1, #0x4000
20000034:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
	str	r1, [r0, #0]
20000038:	6001      	str	r1, [r0, #0]
	@ Take GPIO hardware out of reset
	ldr	r1, [r0, #0]
2000003a:	6801      	ldr	r1, [r0, #0]
	mvn	r2, #0x4000 @ move bitwise negation of 0x4000 into r2
2000003c:	f46f 4280 	mvn.w	r2, #16384	; 0x4000
	and	r1, r2
20000040:	ea01 0102 	and.w	r1, r1, r2
	str	r1, [r0, #0]
20000044:	6001      	str	r1, [r0, #0]

	mov	r0, #24 @bits 24 - 31 are mapped to LEDS 0-7 respectively or D1-D8 on the kit
20000046:	f04f 0018 	mov.w	r0, #24
	bl	initGPIO @ Call initGPIO in gpio.s to initalize GPIO 24
2000004a:	f7ff ffdd 	bl	20000008 <initGPIO>

	mov	r0, #0
2000004e:	f04f 0000 	mov.w	r0, #0
	bl	setGPIO @ Call setGPIO in gpio.s to write 0 to GPIO output register
20000052:	f7ff ffe4 	bl	2000001e <setGPIO>

	movw r3, #:lower16:DELAY_CYCLES
20000056:	f249 6380 	movw	r3, #38528	; 0x9680
	movt r3, #:upper16:DELAY_CYCLES
2000005a:	f2c0 0398 	movt	r3, #152	; 0x98

2000005e <loop>:
loop:
	mov	r1, #1
2000005e:	f04f 0101 	mov.w	r1, #1
	lsl	r1, #24
20000062:	ea4f 6101 	mov.w	r1, r1, lsl #24
	eor	r0, r1 @ Exclusive-OR (XOR)
20000066:	ea80 0001 	eor.w	r0, r0, r1
	bl	setGPIO
2000006a:	f7ff ffd8 	bl	2000001e <setGPIO>
	mov r2, #0
2000006e:	f04f 0200 	mov.w	r2, #0

20000072 <delay>:
delay:
	add r2, r2, #1
20000072:	f102 0201 	add.w	r2, r2, #1
	cmp r2, r3
20000076:	429a      	cmp	r2, r3
	blt delay
20000078:	dbfb      	blt.n	20000072 <delay>

	b loop
2000007a:	e7f0      	b.n	2000005e <loop>
